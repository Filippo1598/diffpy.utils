#!/usr/bin/env python
##############################################################################
#
# diffpy.utils      by DANSE Diffraction group
#                   Simon J. L. Billinge
#                   (c) 2010 The Trustees of Columbia University
#                   in the City of New York.  All rights reserved.
#
# File coded by:
#
# See AUTHORS.txt for a list of people who contributed.
# See LICENSE_DANSE.txt for license information.
#
##############################################################################

import pathlib
import json

# FIXME: add support for yaml, xml
supported_formats = ['.json']


def load_PDF_into_db(dbname, pdfname, hddata: dict, rv: list, show_path=True):
    """Load an entry consisting of PDF header and base data into a database file.

    Requires hdata and rv generated from loadData.

    dbname          -- name of the database file to load an entry into.
    pdfname         -- name of the PDF file.
    hddata          -- Dictionary of PDF metadata generated by loadData.
    rv              -- List of PDF (r, gr) pairs generated by loadData.
    show_path       -- include a PDF_path element in the database entry (default True).

    Returns the dictionary loaded from/into the updated database file.
    """
    # new file or update
    existing = False
    if pathlib.Path.is_file(dbname):
        existing = True

    # collect entry
    with open(pdfname, 'r') as grfile:
        data = {}

        # add path
        grpath = grfile.name
        if show_path:
            data.update({'PDF_path': grpath})

        # add r, gr, and header metadata
        data.update({'r': list(rv[:, 0]), 'gr': list(rv[:, 1])})
        data.update(hddata)

        # parse name using pathlib and generate json entry
        name = pathlib.Path(grpath).name
        entry = {name: data}

    # check if supported type
    extension = pathlib.Path(dbname).suffix
    if extension not in supported_formats:
        raise Exception(f"Format of {dbname} is not supported.")

    # json
    if extension == '.json':
        # dump if non-existing
        if not existing:
            with open(dbname, 'w') as jsonfile:
                pdfs = entry  # for return
                json.dump(pdfs, jsonfile, indent=2)

        # update if existing
        else:
            with open(dbname, 'r') as json_read:
                pdfs = json.load(json_read)
                pdfs.update(entry)
            with open(dbname, 'w') as json_write:
                # dump to string first for formatting
                json.dump(pdfs, json_write, indent=2)

    return pdfs


def load_from_db(filename):
    """Load a dictionary from a database file.

    filename    -- database file to load from.

    Returns a dictionary of database information.
    """

    # check if supported type
    extension = pathlib.Path(filename).suffix
    if extension not in supported_formats:
        raise Exception(f"Format of {filename} is not supported.")

    # json
    if extension == '.json':
        with open(filename, 'r') as json_file:
            j_dict = json.load(json_file)

    return j_dict


def markup_PDF(hddata: dict, rv: list, muname=None):
    # FIXME: may be better suited for REST API package, not diffpy.utils
    """Put PDF file information into a dictionary.

    hddata  -- Dictionary of metadata.
    rv      -- List of (r, gr) pairs.
    muname  -- file to save into (default None, no saving occurs).

    Returns the dictionary loaded from/into markup file.
    """

    # gather data
    data = {}
    data.update({'r': list(rv[:, 0]), 'gr': list(rv[:, 1])})
    data.update(hddata)

    # return directly
    if muname is None:
        return data

    # save to disk when enabled
    extension = pathlib.Path(muname).suffix
    if extension not in supported_formats:
        raise Exception(f"Format of {muname} is not supported.")

    # dumps into file, automatically overwrites
    if extension == '.json':
        with open(muname, 'w') as json_write:
            json.dump(data, json_write, indent=2)

    return data


def markup_oneline(filename):
    """Reformat lists in markup languages to take up only one line.

    Works well when only lists are surrounded by square brackets and no other data is comma and newline separated.

    filename    -- name of markup file to reformat.
    """

    # check file type
    extension = pathlib.Path(filename).suffix
    if extension not in supported_formats:
        raise Exception(f"Format of {filename} is not supported.")

    if extension == '.json':
        # cannot easily do regex substitution since lists are of floats
        with open(filename, 'r+') as json_file:
            lines = json_file.readlines()
            json_file.seek(0)
            json_file.truncate()

            s_flag = False
            for line in lines:
                if "\"r\": [" in line or "\"gr\": [" in line:
                    s_flag = True
                    updated_line = line[:-1]
                elif "]," in line:
                    s_flag = False
                    updated_line = f"{updated_line[:-1]}{line.strip()}\n"
                    json_file.write(updated_line)
                elif s_flag:
                    updated_line += f"{line[:-1].strip()} "
                else:
                    json_file.write(line)


def apply_schema_to_file(filename, schemaname, multiple_entries=False):
    """ Reformat a file so relevant entries match the same order as a schema file.
    Other entries are put at the end in the same order.

    filename            -- name of file to apply the schema to.
    schemaname          -- name of schema to apply.
    multiple_entries    -- True if database file (i.e. those generated by load_PDF_into_db).
                           False if data from a single file (i.e. those generated by markup_PDF).

    Returns the dictionary loaded from/into the reformatted file.
    """

    # ensure proper extension
    file_ext = pathlib.Path(filename).suffix
    schema_ext = pathlib.Path(schemaname).suffix
    if file_ext != schema_ext:
        return Exception("Schema type does not match file type.")
    if file_ext not in supported_formats:
        return Exception(f"Format of {filename} is not supported.")

    # json
    if file_ext == ".json":
        with open(schemaname, 'r') as jsonschema:
            schema = json.load(jsonschema)
            schema_order = []
            for dp in schema:
                schema_order.append(dp)

        # database file
        if multiple_entries:
            # reformat each entry in a collection
            with open(filename, 'r') as json_read:
                data_dict = json.load(json_read)
                reformatted_dict = {}  # new dictionary for entire json
                for entry in data_dict.keys():
                    # reformat each entry
                    entry_dict = data_dict.get(entry)
                    reformatted_entry = {}  # new dictionary for a particular entry
                    for dp in schema_order:
                        if dp in entry_dict:
                            reformatted_entry.update({dp: entry_dict.get(dp)})
                            entry_dict.pop(dp)
                    reformatted_entry.update(entry_dict)
                    reformatted_dict.update({entry: reformatted_entry})
            with open(filename, 'w') as json_write:
                json.dump(reformatted_dict, json_write, indent=2)

        # single file
        else:
            with open(filename, 'r') as json_read:
                data_dict = json.load(json_read)
                reformatted_dict = {}
                # reformat
                for dp in schema_order:
                    if dp in data_dict:
                        reformatted_dict.update({dp: data_dict.get(dp)})
                        data_dict.pop(dp)
                reformatted_dict.update(data_dict)
            with open(filename, 'w') as json_write:
                json.dump(reformatted_dict, json_write, indent=2)

    return reformatted_dict
